{"version":3,"file":"supernova-exporter-css-like.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["import shortenCssHex from 'shorten-css-hex';\n\nfunction shortenHex(hexValue) {\n  const shortenedHex = shortenCssHex('#' + hexValue);\n  return shortenedHex;\n}\n\nPulsar.registerFunction(\"shortenHex\", shortenHex);\n\n/**\n * Convert group name, token name and possible prefix into camelCased string, joining everything together\n */\n Pulsar.registerFunction(\n  \"readableVariableName\",\n  function (token, tokenGroup) {\n    const segments = [...tokenGroup.path];\n    segments.push(tokenGroup.name);\n    segments.push(token.name);\n\n    let tokenName = segments.join(\"-\");\n\n    tokenName = tokenName.replace(/[^a-zA-Z0-9_-]/g, '');\n\n    return tokenName.toLowerCase();\n  }\n);\n\nfunction findAliases(token, allTokens){\n  let aliases = allTokens.filter(t => t.value.referencedToken && t.value.referencedToken.id === token.id)\n  for (const t of aliases) {\n    aliases = aliases.concat(findAliases(t, allTokens))\n  }\n  return aliases;\n}\n\nPulsar.registerFunction(\"findAliases\", findAliases)\n\nPulsar.registerFunction(\"gradientAngle\", function(from, to) {\n    var deltaY = (to.y - from.y);\n    var deltaX = (to.x - from.x);\n    var radians = Math.atan2(deltaY, deltaX); \n    var result = radians * 180 / Math.PI; \n    result = result + 90; \n    return  ((result < 0) ? (360 + result) : result) % 360;\n})\n\n/**\n * Behavior configuration of the exporter\n * Prefixes: Add prefix for each category of the tokens. For example, all colors can start with \"color, if needed\"\n */\nPulsar.registerPayload(\"behavior\", {\n  colorTokenPrefix: \"color\",\n  borderTokenPrefix: \"border\",\n  gradientTokenPrefix: \"gradient\",\n  measureTokenPrefix: \"measure\",\n  shadowTokenPrefix: \"shadow\",\n  typographyTokenPrefix: \"typography\",\n  textTokenPrefix: \"text\"\n});\n\n\n/** Describe complex shadow token */\nPulsar.registerFunction(\"shadowDescription\", function (shadowToken) {\n  \n  let connectedShadow = \"transparent\"\n  if (shadowToken.shadowLayers) {\n    connectedShadow = shadowToken.shadowLayers.reverse().map((shadow) => {\n        return shadowTokenValue(shadow)\n    }).join(\", \")\n  } else {\n    return shadowTokenValue(shadowToken)\n  }\n\n  return connectedShadow ?? \"\"\n})\n\n/** Convert complex shadow value to CSS representation */\nfunction shadowTokenValue(shadowToken) {\n  var blurRadius = getValueWithCorrectUnit(nonNegativeValue(shadowToken.value.radius.measure));\n  var offsetX = getValueWithCorrectUnit(shadowToken.value.x.measure);\n  var offsetY = getValueWithCorrectUnit(shadowToken.value.y.measure);\n  var spreadRadius = getValueWithCorrectUnit(shadowToken.value.spread.measure);\n\n  return `${shadowToken.value.type === \"Inner\" ? \"inset \" : \"\"}${offsetX} ${offsetY} ${blurRadius} ${spreadRadius} ${getFormattedRGB(shadowToken.value.color)}`\n}\n\n\nfunction getValueWithCorrectUnit(value) {\n  if (value === 0) {\n    return `${value}`\n  } else {\n    // todo: add support for other units (px, rem, em, etc.)\n    return `${value}px`\n  }\n}\n\nfunction nonNegativeValue(num) {\n  if (num <= 0) {\n    return 0\n  } else {\n    return num\n  }\n}\n\n/** Convert type to CSS unit */\nfunction measureTypeIntoReadableUnit(type) {\n  switch (type) {\n    case \"Points\":\n      return \"pt\"\n    case \"Pixels\":\n      return \"px\"\n    case \"Percent\":\n      return \"%\"\n    case \"Ems\":\n      return \"em\"\n  }\n}\n\nfunction getFormattedRGB(colorValue) {\n  if (colorValue.a === 0) {\n    return `rgb(${colorValue.r},${colorValue.g},${colorValue.b})`\n  } else {\n    const opacity = Math.round((colorValue.a/255) * 100) / 100;\n    return `rgba(${colorValue.r},${colorValue.g},${colorValue.b},${opacity})`\n  } \n}"],"names":["shadowTokenValue","shadowToken","num","blurRadius","getValueWithCorrectUnit","value","radius","measure","offsetX","x","offsetY","y","spreadRadius","spread","type","colorValue","a","r","g","b","opacity","Math","round","getFormattedRGB","color","Pulsar","registerFunction","hexValue","shortenCssHex","token","tokenGroup","segments","path","push","name","tokenName","join","replace","toLowerCase","findAliases","allTokens","aliases","filter","t","referencedToken","id","concat","from","to","result","atan2","PI","registerPayload","colorTokenPrefix","borderTokenPrefix","gradientTokenPrefix","measureTokenPrefix","shadowTokenPrefix","typographyTokenPrefix","textTokenPrefix","shadowLayers","reverse","map","shadow"],"mappings":"6MA6EA,SAASA,EAAiBC,GACxB,IAkBwBC,EAlBpBC,EAAaC,GAkBOF,EAlBkCD,EAAYI,MAAMC,OAAOC,UAmBxE,EACF,EAEAL,GArBLM,EAAUJ,EAAwBH,EAAYI,MAAMI,EAAEF,SACtDG,EAAUN,EAAwBH,EAAYI,MAAMM,EAAEJ,SACtDK,EAAeR,EAAwBH,EAAYI,MAAMQ,OAAON,SAEpE,OAAqC,UAA3BN,EAAYI,MAAMS,KAAmB,SAAW,IAAKN,MAAWE,MAAWP,MAAcS,MAmCrG,SAAyBG,GACvB,GAAqB,IAAjBA,EAAWC,EACb,aAAcD,EAAWE,MAAKF,EAAWG,MAAKH,EAAWI,MAEzD,IAAMC,EAAUC,KAAKC,MAAOP,EAAWC,EAAE,IAAO,KAAO,IACvD,cAAeD,EAAWE,MAAKF,EAAWG,MAAKH,EAAWI,MAAKC,MAxCkDG,CAAgBtB,EAAYI,MAAMmB,OAIvJ,SAASpB,EAAwBC,GAC/B,OAAc,IAAVA,KACQA,EAGAA,OArFdoB,OAAOC,iBAAiB,cALxB,SAAoBC,GAElB,OADqBC,EAAc,IAAMD,MAS1CF,OAAOC,iBACN,wBACA,SAAUG,EAAOC,GACf,IAAMC,YAAeD,EAAWE,MAChCD,EAASE,KAAKH,EAAWI,MACzBH,EAASE,KAAKJ,EAAMK,MAEpB,IAAIC,EAAYJ,EAASK,KAAK,KAI9B,OAFAD,EAAYA,EAAUE,QAAQ,kBAAmB,KAEhCC,iBAYrBb,OAAOC,iBAAiB,eARxB,SAASa,EAAYV,EAAOW,GAE1B,IADA,MAAIC,EAAUD,EAAUE,QAAO,SAAAC,GAAC,OAAIA,EAAEtC,MAAMuC,iBAAmBD,EAAEtC,MAAMuC,gBAAgBC,KAAOhB,EAAMgB,4rBACpFJ,kBACdA,EAAUA,EAAQK,OAAOP,UAAeC,IAE1C,OAAOC,KAKThB,OAAOC,iBAAiB,iBAAiB,SAASqB,EAAMC,GACpD,IAGIC,EAAmB,IADT5B,KAAK6B,MAFLF,EAAGrC,EAAIoC,EAAKpC,EACZqC,EAAGvC,EAAIsC,EAAKtC,GAEGY,KAAK8B,GAElC,QADAF,GAAkB,IACC,EAAM,IAAMA,EAAUA,GAAU,OAOvDxB,OAAO2B,gBAAgB,WAAY,CACjCC,iBAAkB,QAClBC,kBAAmB,SACnBC,oBAAqB,WACrBC,mBAAoB,UACpBC,kBAAmB,SACnBC,sBAAuB,aACvBC,gBAAiB,SAKnBlC,OAAOC,iBAAiB,qBAAqB,SAAUzB,SAGrD,OAAIA,EAAY2D,sBACI3D,EAAY2D,aAAaC,UAAUC,KAAI,SAACC,GACtD,OAAO/D,EAAiB+D,MACzB3B,KAAK,SAKgB,GAHjBpC,EAAiBC"}